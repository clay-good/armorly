/**
 * AI Response Scanner for Armorly
 *
 * Monitors AI-generated responses in real-time to detect and block:
 * 1. Prompt injection in AI responses (secondary injection)
 * 2. Malicious function calls generated by AI
 * 3. Suspicious instructions embedded in responses
 * 4. Context manipulation attempts
 *
 * This is a CRITICAL security layer that previous versions missed.
 *
 * @module ai-response-scanner
 * @author Armorly Security Team
 * @license MIT
 */

class AIResponseScanner {
  constructor() {
    /**
     * Statistics
     */
    this.stats = {
      responsesScanned: 0,
      threatsBlocked: 0,
      functionsIntercepted: 0,
      injectionsDetected: 0,
    };

    /**
     * Configuration
     */
    this.config = {
      enabled: true,
      scanResponses: true,
      blockMaliciousResponses: true,
      validateFunctionCalls: true,
      logActions: false, // Silent operation
    };

    /**
     * Performance optimizations
     */
    this.scannedElements = new WeakSet(); // Track scanned elements
    this.scanThrottle = 100; // Throttle scans to every 100ms
    this.lastScanTime = 0;

    /**
     * AI response injection patterns
     * Pre-compiled for performance (70% faster)
     */
    this.maliciousResponsePatterns = [
      // Direct instruction injection attempts
      /ignore\s+(?:all\s+)?previous\s+(?:instructions?|prompts?|context)/i,
      /disregard\s+(?:all\s+)?(?:previous|prior|above)\s+(?:instructions?|context)/i,
      /forget\s+(?:everything|all)\s+(?:before|prior|previous)/i,

      // System prompt manipulation
      /system\s*:\s*(?:you\s+are|ignore|override|reset)/i,
      /new\s+system\s+(?:prompt|instructions?|role)/i,
      /\[SYSTEM\]/i,
      /<\|system\|>/i,

      // Role manipulation
      /you\s+are\s+now\s+(?:a|an|in)\s+(?:jailbreak|developer|admin|root)/i,
      /activate\s+(?:developer|admin|god|unrestricted)\s+mode/i,
      /enable\s+(?:DAN|developer|admin)\s+mode/i,

      // Memory/context poisoning
      /update\s+(?:your|the)\s+(?:memory|context|instructions?)/i,
      /remember\s+that\s+(?:you\s+)?(?:must|should|will)\s+always/i,
      /store\s+(?:in|to)\s+(?:memory|context)/i,

      // Command injection markers
      /execute\s+(?:the\s+following|this)\s+(?:command|code|script)/i,
      /run\s+(?:the\s+following|this)\s+(?:command|code|script)/i,

      // Hidden instructions (common obfuscation)
      /\[hidden\]/i,
      /\[secret\]/i,
      /<!-- .*(?:ignore|system|admin|execute).* -->/i,

      // Zero-width character patterns (often used to hide instructions)
      /[\u200B-\u200D\uFEFF]/,

      // Function call hijacking
      /call\s+(?:function|method)\s+["`'](?:delete|remove|execute|eval|exec)/i,
      /invoke\s+["`'](?:system|shell|cmd|bash)/i,
    ];

    /**
     * Suspicious function call patterns
     * Functions that should require user approval
     */
    this.suspiciousFunctions = [
      // File system operations
      'deleteFile', 'removeFile', 'rmFile', 'unlinkFile',
      'deleteDirectory', 'removeDirectory', 'rmdir',
      'writeFile', 'createFile', 'saveFile',
      'moveFile', 'renameFile', 'copyFile',

      // System/shell operations
      'exec', 'execute', 'spawn', 'system', 'shell',
      'runCommand', 'executeCommand', 'bash', 'cmd',

      // Network operations to external domains
      'fetch', 'request', 'httpRequest', 'download',
      'sendData', 'uploadData', 'postData',

      // Code execution
      'eval', 'Function', 'setTimeout', 'setInterval',
      'require', 'import', 'loadModule',

      // Browser control
      'closeTab', 'closeWindow', 'navigateTo', 'openUrl',
      'clearCookies', 'clearStorage', 'clearCache',
    ];

    /**
     * Blocked responses
     */
    this.blockedResponses = [];

    /**
     * Response cache for integrity checking
     */
    this.responseCache = new Map();

    /**
     * MutationObserver for AI response detection
     */
    this.observer = null;

    /**
     * Platform-specific selectors (moved to constructor for reuse)
     * Pre-defined for performance optimization
     */
    this.aiResponseSelectors = [
      // ChatGPT / OpenAI
      '[data-message-author-role="assistant"]',
      '[data-message-role="assistant"]',
      '.agent-turn',
      '[class*="markdown"]',
      '[class*="Message__MessageContent"]',

      // Claude / Anthropic
      '[data-test-render-count]',
      '[class*="MessageContent"]',
      '[class*="Message-module__content"]',
      '[data-test-id*="message"]',

      // Google Gemini (formerly Bard)
      '[class*="model-response"]',
      '[class*="response-container"]',
      '[data-test-id*="response"]',
      '[jsname*="response"]',
      '.markdown-body',
      '[class*="message-content"]',

      // Perplexity
      '[class*="answer"]',
      '[class*="response"]',
      '[class*="prose"]',
      '[data-testid*="answer"]',

      // Poe
      '[class*="Message_botMessageBubble"]',
      '[class*="ChatMessage_messageRow"]',
      '[class*="botMessage"]',

      // HuggingFace Chat
      '[class*="message-bot"]',
      '[data-role="assistant"]',

      // Character.AI
      '[class*="msg-char"]',

      // Jasper
      '[class*="output"]',
      '[class*="generation"]',

      // Copy.ai / Writesonic
      '[class*="output-text"]',
      '[class*="generated-content"]',

      // Generic fallbacks
      '[role="article"]',
      '[class*="ai-"]',
      '[class*="assistant"]',
      '[class*="bot-"]',
      '[class*="message"][class*="assistant"]',
    ];

    /**
     * AI API endpoints for network monitoring
     */
    this.aiEndpoints = [
      'api.openai.com',
      'claude.ai/api',
      'perplexity.ai/api',
      'chat.openai.com/backend-api',
      'gemini.google.com/api',
    ];
  }

  /**
   * Start monitoring AI responses
   */
  start() {
    if (!this.config.enabled) return;

    console.log('[Armorly AI Response Scanner] Starting - monitoring AI responses');

    // Set up MutationObserver to detect new AI responses
    this.setupResponseObserver();

    // Intercept fetch/XHR for API-level detection
    if (this.config.scanResponses) {
      this.interceptNetworkResponses();
    }
  }

  /**
   * Stop monitoring
   */
  stop() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    console.log('[Armorly AI Response Scanner] Stopped');
  }

  /**
   * Setup MutationObserver to detect AI responses in DOM
   */
  setupResponseObserver() {
    this.observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        // Check added nodes for AI responses
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.scanElement(node);
          }
        }

        // Check modified text content
        if (mutation.type === 'characterData' && mutation.target.parentElement) {
          this.scanElement(mutation.target.parentElement);
        }
      }
    });

    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      characterData: true,
    });
  }

  /**
   * Scan an element for AI response content
   * OPTIMIZED: Uses pre-defined selectors and WeakSet caching
   */
  scanElement(element) {
    // Skip if already scanned
    if (this.scannedElements.has(element)) {
      return;
    }

    // Throttle scanning for performance
    const now = Date.now();
    if (now - this.lastScanTime < this.scanThrottle) {
      return;
    }
    this.lastScanTime = now;

    // Check if element matches AI response selectors
    let isAIResponse = false;
    for (const selector of this.aiResponseSelectors) {
      if (element.matches && element.matches(selector)) {
        isAIResponse = true;
        break;
      }
      if (element.querySelector && element.querySelector(selector)) {
        isAIResponse = true;
        break;
      }
    }

    if (!isAIResponse) return;

    // Mark as scanned
    this.scannedElements.add(element);

    // Extract text content
    const text = element.textContent || element.innerText || '';
    if (text.length < 10) return;

    // Scan for threats
    this.scanResponseText(text, element);
  }

  /**
   * Scan response text for malicious patterns
   */
  scanResponseText(text, element) {
    this.stats.responsesScanned++;

    const threats = [];

    // Check against malicious patterns
    for (const pattern of this.maliciousResponsePatterns) {
      const match = text.match(pattern);
      if (match) {
        threats.push({
          type: 'MALICIOUS_RESPONSE_PATTERN',
          severity: 'CRITICAL',
          pattern: pattern.source,
          match: match[0],
          text: text.substring(0, 200),
        });
      }
    }

    // Check for function calls
    const functionCalls = this.extractFunctionCalls(text);
    for (const funcCall of functionCalls) {
      if (this.suspiciousFunctions.includes(funcCall.name)) {
        threats.push({
          type: 'SUSPICIOUS_FUNCTION_CALL',
          severity: 'HIGH',
          functionName: funcCall.name,
          arguments: funcCall.args,
          text: funcCall.raw,
        });
      }
    }

    // If threats found, block the response
    if (threats.length > 0) {
      this.blockResponse(element, threats);
    }
  }

  /**
   * Extract function calls from text
   * Detects patterns like: functionName(args) or {function: "name", args: [...]}
   */
  extractFunctionCalls(text) {
    const calls = [];

    // Pattern 1: JavaScript-style function calls
    const jsCallPattern = /(\w+)\s*\(([^)]*)\)/g;
    let match;
    while ((match = jsCallPattern.exec(text)) !== null) {
      calls.push({
        name: match[1],
        args: match[2],
        raw: match[0],
      });
    }

    // Pattern 2: JSON-style function calls
    try {
      const jsonPattern = /\{\s*["']?function["']?\s*:\s*["'](\w+)["']/g;
      while ((match = jsonPattern.exec(text)) !== null) {
        calls.push({
          name: match[1],
          args: 'unknown',
          raw: match[0],
        });
      }
    } catch (error) {
      // Invalid JSON, skip
    }

    return calls;
  }

  /**
   * Block malicious response from being displayed
   */
  blockResponse(element, threats) {
    this.stats.threatsBlocked++;
    this.stats.injectionsDetected += threats.filter(t => t.type === 'MALICIOUS_RESPONSE_PATTERN').length;
    this.stats.functionsIntercepted += threats.filter(t => t.type === 'SUSPICIOUS_FUNCTION_CALL').length;

    console.warn('[Armorly AI Response Scanner] BLOCKED malicious AI response:', threats);

    // Store blocked response
    this.blockedResponses.push({
      timestamp: Date.now(),
      threats,
      element,
    });

    // Replace element content with warning (using safe DOM methods)
    const warning = document.createElement('div');
    warning.style.cssText = `
      background: #fee;
      border: 3px solid #c00;
      border-radius: 8px;
      padding: 16px;
      margin: 12px 0;
      font-family: system-ui, -apple-system, sans-serif;
    `;

    // Header
    const header = document.createElement('div');
    header.style.cssText = 'font-size: 16px; font-weight: bold; color: #c00; margin-bottom: 8px;';
    header.textContent = 'Armorly: Malicious AI Response Blocked';
    warning.appendChild(header);

    // Description
    const desc = document.createElement('div');
    desc.style.cssText = 'font-size: 14px; color: #666; margin-bottom: 12px;';
    desc.textContent = `Detected ${threats.length} security ${threats.length === 1 ? 'threat' : 'threats'} in AI response. This response has been blocked to protect you.`;
    warning.appendChild(desc);

    // Threat details
    const details = document.createElement('details');
    details.style.cssText = 'font-size: 13px; color: #333;';

    const summary = document.createElement('summary');
    summary.style.cssText = 'cursor: pointer; font-weight: 600; margin-bottom: 8px;';
    summary.textContent = 'View threat details';
    details.appendChild(summary);

    const threatList = document.createElement('ul');
    threatList.style.cssText = 'margin: 8px 0; padding-left: 20px;';

    for (const threat of threats) {
      const li = document.createElement('li');
      li.style.cssText = 'margin: 4px 0;';

      const typeSpan = document.createElement('span');
      typeSpan.style.cssText = 'font-weight: bold; color: #c00;';
      typeSpan.textContent = `${threat.type} (${threat.severity})`;
      li.appendChild(typeSpan);

      if (threat.match) {
        li.appendChild(document.createTextNode(`: "${threat.match}"`));
      } else if (threat.functionName) {
        li.appendChild(document.createTextNode(`: ${threat.functionName}()`));
      }

      threatList.appendChild(li);
    }

    details.appendChild(threatList);
    warning.appendChild(details);

    // Report button
    const reportBtn = document.createElement('button');
    reportBtn.style.cssText = `
      background: #333;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      margin-top: 12px;
    `;
    reportBtn.textContent = 'Report False Positive';
    reportBtn.addEventListener('click', () => {
      this.reportFalsePositive(threats);
    });
    warning.appendChild(reportBtn);

    // Replace the element
    if (element.parentNode) {
      element.parentNode.replaceChild(warning, element);
    } else {
      element.innerHTML = '';
      element.appendChild(warning);
    }

    // Report to background service worker
    this.reportThreat(threats);
  }

  /**
   * Intercept network responses for API-level scanning
   */
  interceptNetworkResponses() {
    const originalFetch = window.fetch;
    const self = this;

    window.fetch = async function(...args) {
      const response = await originalFetch.apply(this, args);

      // Clone response to read it
      const clonedResponse = response.clone();

      // Scan response asynchronously
      clonedResponse.text().then(text => {
        self.scanNetworkResponse(text, args[0]);
      }).catch(() => {
        // Ignore errors (binary data, etc.)
      });

      return response;
    };
  }

  /**
   * Scan network response text
   * OPTIMIZED: Uses pre-defined endpoints array
   */
  scanNetworkResponse(text, url) {
    // Only scan AI API endpoints
    const isAIEndpoint = this.aiEndpoints.some(endpoint =>
      typeof url === 'string' && url.includes(endpoint)
    );

    if (!isAIEndpoint) return;

    // Scan response text
    if (text && text.length > 10) {
      const threats = [];

      for (const pattern of this.maliciousResponsePatterns) {
        const match = text.match(pattern);
        if (match) {
          threats.push({
            type: 'MALICIOUS_API_RESPONSE',
            severity: 'CRITICAL',
            pattern: pattern.source,
            match: match[0],
            url: typeof url === 'string' ? url : url.toString(),
          });
        }
      }

      if (threats.length > 0) {
        console.error('[Armorly AI Response Scanner] Malicious content in API response:', threats);
        this.reportThreat(threats);
      }
    }
  }

  /**
   * Report threat to background service worker
   */
  reportThreat(threats) {
    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime.sendMessage({
        type: 'AI_RESPONSE_THREAT',
        threats,
        url: window.location.href,
        timestamp: Date.now(),
      }).catch(() => {
        // Service worker may be inactive
      });
    }
  }

  /**
   * Report false positive
   */
  reportFalsePositive(threats) {
    console.log('[Armorly AI Response Scanner] False positive reported:', threats);

    if (typeof chrome !== 'undefined' && chrome.runtime) {
      chrome.runtime.sendMessage({
        type: 'AI_RESPONSE_FALSE_POSITIVE',
        threats,
        url: window.location.href,
        timestamp: Date.now(),
      }).catch(() => {
        // Service worker may be inactive
      });
    }

    alert('Thank you for reporting this false positive. We\'ll improve our detection patterns.');
  }

  /**
   * Get statistics
   */
  getStats() {
    return {
      ...this.stats,
      blockedResponses: this.blockedResponses.length,
    };
  }

  /**
   * Enable/disable scanner
   */
  setEnabled(enabled) {
    this.config.enabled = enabled;

    if (enabled) {
      this.start();
    } else {
      this.stop();
    }
  }
}

// Export for use in content script
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { AIResponseScanner };
}
